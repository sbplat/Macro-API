#include <macro/macro.h>

#include <chrono>
#include <fstream>
#include <iostream>
#include <sstream>
#include <string>
#include <thread>
#include <vector>

std::vector<std::string> commands;

long long lastTime;

long long getTimestamp() {
    return std::chrono::duration_cast<std::chrono::milliseconds>(
               std::chrono::system_clock::now().time_since_epoch())
        .count();
}

void addSleepCommand() {
    long long currentTime = getTimestamp();
    long long delta = currentTime - lastTime;
    if (delta > 0) {
        commands.push_back("Misc::Sleep(" + std::to_string(delta) + ");");
    }
    lastTime = currentTime;
}

bool moveCallback(Macro::Mouse::Point position) {
    addSleepCommand();
    std::stringstream ss;
    ss << "Mouse::MoveAbsolute(" << position.x << ", " << position.y << ");";
    commands.push_back(ss.str());
    return false;
}

bool buttonCallback(Macro::Mouse::Button button, Macro::Mouse::ButtonState state) {
    addSleepCommand();
    std::stringstream ss;
    ss << "Mouse::" << (state == Macro::Mouse::ButtonState::DOWN ? "Down" : "Up")
       << "(Mouse::Button::" << Macro::Mouse::GetButtonName(button) << ");";
    commands.push_back(ss.str());
    return false;
}

bool scrollCallback(int delta, bool horizontal) {
    addSleepCommand();
    std::stringstream ss;
    ss << "Mouse::Scroll(" << delta << ", " << (horizontal ? "true" : "false") << ");";
    commands.push_back(ss.str());
    return false;
}

bool keyCallback(Macro::Keyboard::Key key, Macro::Keyboard::KeyState state) {
    addSleepCommand();
    std::stringstream ss;
    ss << "Keyboard::" << (state == Macro::Keyboard::KeyState::DOWN ? "Down" : "Up")
       << "(Keyboard::Key::" << Macro::Keyboard::GetKeyName(key) << ");";
    commands.push_back(ss.str());
    return false;
}

int main() {
    // Register all of our callbacks.
    Macro::Mouse::SetMoveCallback(moveCallback);
    Macro::Mouse::SetButtonCallback(buttonCallback);
    Macro::Mouse::SetScrollCallback(scrollCallback);
    Macro::Keyboard::SetCallback(keyCallback);

    // Start both of our hook loops in separate threads.
    std::thread(Macro::Mouse::MouseHookLoop).detach();
    std::thread(Macro::Keyboard::KeyboardHookLoop).detach();

    std::cout << "Press F4 to stop recording." << std::endl;

    while (true) {
        Macro::Keyboard::KeyState f4State = Macro::Keyboard::GetKeyState(Macro::Keyboard::F4);
        if (f4State == Macro::Keyboard::KeyState::DOWN) {
            // Stop the macro recorder by setting all of our callbacks to nullptr.
            Macro::Mouse::SetMoveCallback(nullptr);
            Macro::Mouse::SetButtonCallback(nullptr);
            Macro::Mouse::SetScrollCallback(nullptr);
            Macro::Keyboard::SetCallback(nullptr);
            break;
        }
        std::this_thread::yield();  // Yield to avoid eating up all of the CPU.
    }

    // Remove the first sleep command.
    commands.erase(commands.begin());

    // Remove the last F4 key down command and the sleep command before it.
    commands.pop_back();  // F4 key down
    commands.pop_back();  // Sleep

    // Write the recorded macro as C++ code to a file.
    std::ofstream file("generated_macro.cpp", std::ios::trunc);
    file << "// Code generated by examples/code_generator.cpp\n"
         << "#include <macro/macro.h>\n"
         << "\n"
         << "using namespace Macro;\n"
         << "\n"
         << "int main() {\n";
    for (std::string command : commands) {
        file << "    " << command << "\n";
    }
    file << "    return 0;\n"
         << "}\n";
    file.close();

    return 0;
}
